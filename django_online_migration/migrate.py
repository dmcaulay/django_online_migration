"""Migration tool"""

import datetime
import numbers

from django.db import connections
from time import sleep

from django_online_migration.utils import retry_on_deadlock

SQL_ANNOTATION = '/* generated by the migration tool */'
CHUNK_SIZE = 40000
DEFAULT_THROTTLE = 0.1
MAX_RENAME_RETRIES = 600
RETRY_SLEEP_TIME = 10
MAX_IDENTIFIER = 64

# pylint: disable=print-statement


def execute(db_name, sql):
    """Execute a SQL statement on the given database"""
    connection = connections[db_name]
    dbc = connection.cursor()
    dbc.execute(sql)
    return dbc.fetchall()


def dest_name(table_name):
    """Return the destination table name"""
    return ("migrate_%s" % table_name)[:MAX_IDENTIFIER]


def archive_name(table_name):
    """Return the archive table name"""
    return ("archive_%s" % table_name)[:MAX_IDENTIFIER]


def change_table(db_name, table_name, create_stmt, index_stmts, origin_columns, dest_columns, **kwargs):
    """The migration"""
    create_dest(db_name, table_name, create_stmt)
    create_indexes(db_name, table_name, index_stmts)

    renames = kwargs.get('renames', {})
    intersection = Intersection(origin_columns, dest_columns, renames)
    create_triggers(db_name, table_name, intersection)
    copy_in_chunks(db_name, table_name, intersection, **kwargs)


def restart_copy(db_name, table_name, origin_columns, dest_columns, **kwargs):
    """Restart copy_in_chunks"""
    renames = kwargs.get('renames', {})
    intersection = Intersection(origin_columns, dest_columns, renames)
    copy_in_chunks(db_name, table_name, intersection, **kwargs)


def finish_migration(db_name, table_name):
    """Rename the tables and delete the triggers"""
    if rename_tables(db_name, table_name):
        delete_triggers(db_name, table_name)
    else:
        print "ERROR: rename failed!"


# Helper functions for the destination table creation
def create_dest(db_name, table_name, origin_create):
    """Create the destination table"""
    origin = "CREATE TABLE `%s`" % table_name
    replacement = "CREATE TABLE `%s`" % dest_name(table_name)
    dest_create = origin_create.replace(origin, replacement)
    execute(db_name, dest_create)


def create_indexes(db_name, table_name, origin_indexes):
    """Create indexes on the destination table"""
    for origin_index in origin_indexes:
        origin = "ON `%s`" % table_name
        replacement = "ON `%s`" % dest_name(table_name)
        dest_index = origin_index.replace(origin, replacement)
        execute(db_name, dest_index)


# Helper functions for creating triggers
def trigger_name(t, table_name):
    """The trigger name for a give trigger type t"""
    return ("migration_trigger_%s_%s" % (t, table_name))[:MAX_IDENTIFIER]


def create_triggers(db_name, table_name, intersection):
    """Create triggers to update during the migration"""
    execute(db_name, create_insert_trigger_sql(table_name, intersection))
    execute(db_name, create_update_trigger_sql(table_name, intersection))
    execute(db_name, create_delete_trigger_sql(table_name, intersection))


def delete_triggers(db_name, table_name):
    """Delete the triggers used during the migration"""
    for t in ["insert", "update", "delete"]:
        execute(db_name, "DROP TRIGGER IF EXISTS `%s`" % trigger_name(t, table_name))


def create_insert_trigger_sql(table_name, intersection):
    """The SQL for the insert trigger used during the migration"""
    format_args = dict(
        trigger=trigger_name("insert", table_name),
        table_name=table_name,
        dest_name=dest_name(table_name),
        dest_columns=joined(intersection.dest_columns()),
        origin_columns=typed('NEW', intersection.origin_columns()),
        annotation=SQL_ANNOTATION,
    )
    return (
        """
        CREATE TRIGGER `{trigger}`
        AFTER INSERT ON `{table_name}` FOR EACH ROW
        REPLACE INTO `{dest_name}` ({dest_columns}) {annotation}
        VALUES ({origin_columns})
        """.format(**format_args)
    )


def create_update_trigger_sql(table_name, intersection):
    """The SQL for the update trigger used during the migration"""
    format_args = dict(
        trigger=trigger_name("update", table_name),
        table_name=table_name,
        dest_name=dest_name(table_name),
        dest_columns=joined(intersection.dest_columns()),
        origin_columns=typed('NEW', intersection.origin_columns()),
        annotation=SQL_ANNOTATION,
    )
    return (
        """
        CREATE TRIGGER `{trigger}`
        AFTER UPDATE ON `{table_name}` FOR EACH ROW
        REPLACE INTO `{dest_name}` ({dest_columns}) {annotation}
        VALUES ({origin_columns})
        """.format(**format_args)
    )


def create_delete_trigger_sql(table_name, intersection):
    """The SQL for the delete trigger used during the migration"""
    format_args = dict(
        trigger=trigger_name("delete", table_name),
        table_name=table_name,
        dest_name=dest_name(table_name),
        dest_columns=joined(intersection.dest_columns()),
        origin_columns=typed('NEW', intersection.origin_columns()),
        annotation=SQL_ANNOTATION,
    )
    return (
        """
        CREATE TRIGGER `{trigger}`
        AFTER DELETE ON `{table_name}` FOR EACH ROW
        DELETE IGNORE FROM `{dest_name}` {annotation}
        WHERE `{dest_name}`.`id` = OLD.`id`
        """.format(**format_args)
    )


def copy_in_chunks(db_name, table_name, intersection, **kwargs):
    """Copy the data for the original table to the destination table in chucks"""
    # we can't just use kwargs.get('chunk_size', CHUNK_SIZE) because the Django command
    # class defaults options to None :-(
    chunk_size = kwargs.get('chunk_size', False) or CHUNK_SIZE
    throttle_timeout = kwargs.get('throttle', False) or DEFAULT_THROTTLE
    start = kwargs.get('start', False) or select_start(db_name, table_name)
    limit = kwargs.get('limit', False) or select_limit(db_name, table_name)
    start_time = datetime.datetime.now()

    next_to_insert = start

    def copy_sql(last_id):
        "The SQL used to copy this chunk to the destination table"
        format_args = dict(
            dest_name=dest_name(table_name),
            dest_columns=joined(intersection.dest_columns()),
            select_sql=select_sql(last_id, typed(table_name, intersection.origin_columns())),
        )
        return (
            """
            INSERT IGNORE INTO `{dest_name}` ({dest_columns})
            {select_sql}
            """.format(**format_args)
        )

    def select_sql(last_id, columns):
        "The SQL used to select the chunk"
        format_args = dict(
            columns=columns,
            table_name=table_name,
            last_id=last_id,
            chunk_size=chunk_size,
        )
        return (
            """
            SELECT {columns} FROM `{table_name}`
            WHERE `{table_name}`.`id` >= "{last_id}"
            ORDER BY `{table_name}`.`id`
            LIMIT {chunk_size}
            """.format(**format_args)
        )

    def get_next_id(old_last):
        "Get the next id to query the next chunk"
        next_id_sql = "SELECT MAX(id) FROM (%s) AS T1" % select_sql(old_last, "`id`")
        ((next_id,),) = execute(db_name, next_id_sql)
        return next_id

    def log(current, last):
        ""
        if isinstance(current, numbers.Number):
            percent_complete = (current - start) / (float(last) - start)
            if percent_complete == 0:
                return
            run_time = (datetime.datetime.now() - start_time).total_seconds()
            remaining = run_time / percent_complete
            prediciton = start_time + datetime.timedelta(0, remaining)
            print "processed %d/%d %.2f%% - predicted completion: %s" % (current, last, percent_complete*100, str(prediciton))
        else:
            print "processed id %s limit is %s" % (current, last)

    # this assumes there is more than one row in the table
    # be careful when changing the next id logic it can get
    # tricky when we don't have auto incrementing ids.
    # this logic accounts for added rows during the migration
    # but it could potentially miss rows if something is
    # deleted.
    while next_to_insert < limit:
        retry_on_deadlock(lambda: execute(db_name, copy_sql(next_to_insert)))
        next_to_insert = get_next_id(next_to_insert)
        log(next_to_insert, limit)
        sleep(throttle_timeout)

    print "copy complete!"


def select_start(db_name, table_name):
    """Return the min id for the table"""
    ((start,),) = execute(db_name, "SELECT MIN(id) FROM `%s`" % table_name)
    return start


def select_limit(db_name, table_name):
    """Return the max id for the table"""
    ((limit,),) = execute(db_name, "SELECT MAX(id) FROM `%s`" % table_name)
    return limit


def rename_tables(db_name, table_name):
    """Rename the tables in one SQL command"""
    retries = 0
    while True:
        try:
            execute(db_name, rename_tables_sql(table_name))
            return True
        except:
            retries += 1
            if retries > MAX_RENAME_RETRIES:
                return False
            # TODO: make sure this is a Lock wait timeout error before retrying
            print "rename retry %d" % retries
            sleep(RETRY_SLEEP_TIME)


def rename_tables_sql(table_name):
    """Build the rename tables SQL"""
    format_args = dict(
        table_name=table_name,
        archive_name=archive_name(table_name),
        dest_name=dest_name(table_name),
    )
    return (
        """
        RENAME TABLE `{table_name}` to `{archive_name}`,
        `{dest_name}` to `{table_name}`
        """.format(**format_args)
    )


class Intersection(object):
    """Determine and format columns common to origin and dest."""

    def __init__(self, origin, dest, renames={}):
        self.origin = origin
        self.dest = dest
        self.renames = renames

    def origin_columns(self):
        "The columns requested when copying from the original table"
        return self.common() + self.renames.keys()

    def dest_columns(self):
        "The columns written to the destination table"
        return self.common() + self.renames.values()

    def common(self):
        "The columns shared between the original and destination tables"
        intersection = list(set(self.origin).intersection(self.dest))
        intersection.sort()
        return intersection


# Helper functions for formating"""
def joined(columns):
    """Columns joined and escaped"""
    return ", ".join([_tick(c) for c in columns])


def typed(t, columns):
    """Columns joined, escaped and qualified with the t name"""
    return ", ".join([_qualified(c, t) for c in columns])


def _qualified(name, t):
    """Add the type before the column name"""
    return "`%s`.`%s`" % (t, name)


def _tick(name):
    """Add quotes around the column name"""
    return "`%s`" % name
